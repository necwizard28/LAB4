/***************************************************
 * Automatically generated by Maple.
 * Created On: Fri Jan 08 16:42:50 2021.
***************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/***************************************************
* Variable Definition for System:

* State variable(s):
*    S.w[ 1] = x[ 0] = `Main.URTK.S2.phi`(t)
*    S.w[ 2] = x[ 1] = diff(`Main.URTK.S2.phi`(t),t)
*    S.w[ 3] = x[ 2] = `Main.URTK.S3.phi`(t)
*    S.w[ 4] = x[ 3] = diff(`Main.URTK.S3.phi`(t),t)
*    S.w[ 5] = x[ 4] = `Main.URTK.S4.phi`(t)
*    S.w[ 6] = x[ 5] = diff(`Main.URTK.S4.phi`(t),t)
*
* Output variable(s):
*    S.w[16] = y[ 0] = `Main.URTK.internal_axisY[1]`(t)
*    S.w[17] = y[ 1] = `Main.URTK.internal_axisY[2]`(t)
*    S.w[18] = y[ 2] = `Main.URTK.internal_axisY[3]`(t)
*    S.w[19] = y[ 3] = `Main.URTK.internal_axisZ[1]`(t)
*    S.w[20] = y[ 4] = `Main.URTK.internal_axisZ[2]`(t)
*    S.w[21] = y[ 5] = `Main.URTK.internal_axisZ[3]`(t)
*    S.w[22] = y[ 6] = `Main.URTK.internal_movementX[1]`(t)
*    S.w[23] = y[ 7] = `Main.URTK.internal_movementX[2]`(t)
*    S.w[24] = y[ 8] = `Main.URTK.internal_movementX[3]`(t)
*    S.w[25] = y[ 9] = `Main.URTK.internal_movementY[1]`(t)
*    S.w[26] = y[10] = `Main.URTK.internal_movementY[2]`(t)
*    S.w[27] = y[11] = `Main.URTK.internal_movementY[3]`(t)
*    S.w[28] = y[12] = `Main.URTK.internal_movementZ[1]`(t)
*    S.w[29] = y[13] = `Main.URTK.internal_movementZ[2]`(t)
*    S.w[30] = y[14] = `Main.URTK.internal_movementZ[3]`(t)
*    S.w[13] = y[15] = `Main.URTK.internal_Ground[1]`(t)
*    S.w[14] = y[16] = `Main.URTK.internal_Ground[2]`(t)
*    S.w[15] = y[17] = `Main.URTK.internal_Ground[3]`(t)
*
* Input variable(s):
*    S.w[31] = u[ 0] = `Main.URTK.Xinputvelocity`(t)
*    S.w[32] = u[ 1] = `Main.URTK.Yimputvelocity`(t)
*    S.w[33] = u[ 2] = `Main.URTK.Zimputevelocity`(t)
*
* Additional Parameter(s):
*    (vr = 74) ap[ 0] = `Main.URTK.minsamplestep` (default = 1/40)
*    (vr = 75) ap[ 1] = `Main.URTK.binfilename` (default = "DISABLED", type = string)
*
************************************************/

/* No scaling - no nominals */
double *nomfac=NULL;
#define MAXERRSTRLENGTH 10000
#define MAXWARNSTRLENGTH 10000
#define WARNNUMDATPTS 100000
#define SSTO 0
/* Wordsize integer definition */
#ifndef M_INT
# if defined _MINGW64 || defined X86_64_WINDOWS
#  define M_INT long long
# elif defined __x86_64__ || defined __ppc64__
#  define M_INT long
# elif defined _M_X64
#  define M_INT long long
# else
#  define M_INT int
# endif
#endif

static int errorOccured = 0;
static char errorString[MAXERRSTRLENGTH+1];
static int warningOccured = 0;
static char warningString[MAXWARNSTRLENGTH+1];

static void SolverError(double t, int term, char *errmsg)
{
	if(term) {
		sprintf(errorString,"Simulation terminated at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 2;
	}
	else {
		sprintf(errorString,"Error at t=%20.16e: %s\n",t,errmsg);
		errorOccured = 1;
	}
}


static void SolverWarning(double t, char *warnmsg)
{
	if(!warningOccured) {
		sprintf(warningString,"Warning at t=%20.16e: %s\n",t,warnmsg);
		warningOccured = 1;
	}
}

/* Fixed parameters */
#define NDIFF 6
#define NDFA 6
#define NEQ 33
#define NPAR 0
#define NINP 3
#define NINPD 0
#define NDISC 0
#define NIX1 27
#define NOUT 18
#define NCON 0
#define NEVT 0

#ifndef max
#define max(a,b) (((a)>(b))?(a):(b))
#endif
#ifndef min
#define min(a,b) (((a)<(b))?(a):(b))
#endif
static double nData[2] = {1.0*NEQ,1.0*NPAR};
static double minsamplestep = 2.50000000000000000e-02;

static void writeErrorToFile(FILE *fptr, char *errstr) {
	char *err, uerr[]="unknown error";
	int i;
	double d;

	if (errstr)
		err = errstr;
	else if (errorOccured)
		err = errorString;
	else
		err = uerr;

	d = -1e10; /*terminate value*/
	fwrite(&d,sizeof(double),1,fptr);
	for(i=0;;i++) {
		d = (double)err[i];
		fwrite(&d,sizeof(double),1,fptr);
		if (!err[i]) break;
	}

	fclose(fptr);
}

static int inputchange=0;

typedef struct {
	double *w;		/* Float workspace */
	M_INT *iw;		/* Integer workspace */
	double *wset;		/* Float workspace */
	double *psto;		/* Float projection workspace */
	double *ssto;		/* Solver storage (implicit) */
} SolverStruct;

static double dsn_zero=0.0;
static unsigned char dsn_undefC[8] = { 0, 0, 0, 0, 0, 0, 0xF8, 0x7F };
static double *dsn_undef = (double *)&dsn_undefC;
static unsigned char dsn_posinfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0x7F };
static double *dsn_posinf = (double *)&dsn_posinfC;
static unsigned char dsn_neginfC[8] = { 0, 0, 0, 0, 0, 0, 0xF0, 0xFF };
static double *dsn_neginf = (double *)&dsn_neginfC;
#define trunc(v) ( (v>0.0) ? floor(v) : ceil(v) )
#define IS_UNDEF(a) (a-a!=0. || (a!=0. && a-2.*a==0.))
#define UNUSED(a) ((void)(a))
double avoidcompilerwarn() { return(dsn_zero+*dsn_undef+*dsn_posinf+*dsn_neginf); }


void fp_sub1(int N, double T, double *Y, double *YP, double *Z)
{
	UNUSED(N);
	UNUSED(T);
	YP[0] = Y[1];
	YP[2] = Y[3];
	YP[4] = Y[5];
	Z[0] = 314.159265358979324;
	YP[1] = Z[0]*(Y[31]-Y[1]);
	YP[3] = Z[0]*(Y[32]-Y[3]);
	YP[5] = Z[0]*(Y[30]-Y[5]);
}

void fp_sub2(double *Y, double *YP, double m, double v)
{
	Y[8] = v/m;
	Y[9] = YP[1];
	Y[10] = YP[3];
	Y[11] = YP[5];
}
static void fp(int N, double T, double *Y, double *YP)
{
	double Z[1], m, v;

	fp_sub1(N,T,Y,YP,Z);
	m = -1.;
	v = -10.204766*YP[5];
	if( m==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[6] = v/m;
	m = -1.;
	v = -3.608292471*YP[1];
	if( m==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	Y[7] = v/m;
	m = -1.;
	v = -5.600412616*YP[3]-54.94004776;
	if( m==0. ) {
		YP[0] = (*dsn_undef);
		return;
	}
	fp_sub2(Y,YP,m,v);
}

static void otp(double T, double *Y, double *YP)
{
	UNUSED(T);
	UNUSED(YP);
	Y[12] = 0.;
	Y[13] = 0.;
	Y[14] = 0.;
	Y[15] = -Y[4]+0.2810269165847487651;
	Y[16] = Y[2]+0.1159999999982802009;
	Y[17] = Y[0]+0.0020000001921696847;
	Y[18] = -Y[4]+0.2530269165847541801;
	Y[19] = 0.0520000000000650428;
	Y[20] = -0.0489999999999722741;
	Y[21] = -Y[4]+0.2030269175;
	Y[22] = 0.038;
	Y[23] = -0.05;
	Y[24] = -Y[4]+0.2670269165847543045;
	Y[25] = Y[2]+0.1167669863515428806;
	Y[26] = -0.04803875526053768433;
	Y[27] = -Y[4]+0.2530269165847542898;
	Y[28] = Y[2]+0.06699999999817218862;
	Y[29] = -0.0490000000000002725;
}

static void auxp(double T, double *Y, double *YP, double *R)
{
	double Z[2];

	UNUSED(T);
	UNUSED(YP);
	Z[0] = 1000.*Y[4];
	R[0] = -Z[0]+253.02691658475419;
	R[1] = -Z[0]+280.67773981947164;
	Z[1] = 1000.*Y[2];
	R[2] = Z[1]+114.875416634342386;
	R[3] = 1000.*Y[0]-267.531018652957528;
	R[4] = -Z[0]+252.314527847464007;
	R[5] = -Z[0]+281.057396502041172;
	R[6] = Z[1]+116.33459872377739;
	R[7] = -Z[0]+252.937018629057775;
	R[8] = Z[1]+117.000000122180495;
}

static int cpr(double T, double *Y)
{
	double v;
	int k;

	UNUSED(T);
	k = 0;
	v = Y[30];
	if( Y[5]!=v ) {
		k = 1;
		Y[5] = v;
	}
	v = Y[32];
	if( Y[3]!=v ) {
		k = 1;
		Y[3] = v;
	}
	v = Y[31];
	if( Y[1]!=v ) {
		k = 1;
		Y[1] = v;
	}
	return(k);
}

static void SolverUpdate(SolverStruct *S, int synced, int commit)
{
	UNUSED(commit);
	if( synced ) return;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

static int SolverProject(SolverStruct *S)
{
	UNUSED(S);
	return(0);
}

static void SolverOutputs(SolverStruct *S)
{
	otp(S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
}

static void RK4Step(double h, SolverStruct *S)
{
	int i;
	double y[NEQ+1],yp1[NDFA],yp2[NDFA],yp3[NDFA];

	for(i=0;i<NEQ+1;i++) y[i]=S->w[i];
	for(i=0;i<NDIFF;i++) yp1[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]+=0.5*h;
	for(i=0;i<NDIFF;i++) S->w[i+1]+=0.5*h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(S,0,0);
	if (errorOccured==1) return;
	for(i=0;i<NDIFF;i++) yp2[i]=S->w[1+NEQ+NPAR+i];
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+0.5*h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(S,0,0);
	if (errorOccured==1) return;
	for(i=0;i<NDIFF;i++) yp3[i]=S->w[1+NEQ+NPAR+i];
	S->w[0]=y[0]+h;
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+h*S->w[1+NEQ+NPAR+i];
	SolverUpdate(S,0,0);
	if (errorOccured==1) return;
	for(i=0;i<NDIFF;i++) S->w[i+1]=y[i+1]+h/6.0*(yp1[i]+2.0*(yp2[i]+yp3[i])+S->w[1+NEQ+NPAR+i]);
}

static void SolverSetup(SolverStruct *S)
{
	int i;

	S->w[0] =  0.00000000000000000e+00;
	S->w[1] =  0.00000000000000000e+00;
	S->w[2] =  2.00000000000000010e-01;
	S->w[3] =  0.00000000000000000e+00;
	S->w[4] =  2.00000000000000010e-01;
	S->w[5] =  0.00000000000000000e+00;
	S->w[6] =  2.00000000000000010e-01;
	S->w[7] =  0.00000000000000000e+00;
	S->w[8] =  0.00000000000000000e+00;
	S->w[9] =  5.49400477599999990e+01;
	S->w[10] =  0.00000000000000000e+00;
	S->w[11] =  0.00000000000000000e+00;
	S->w[12] =  0.00000000000000000e+00;
	S->w[13] =  0.00000000000000000e+00;
	S->w[14] =  0.00000000000000000e+00;
	S->w[15] =  0.00000000000000000e+00;
	S->w[16] =  2.81026916584748760e-01;
	S->w[17] =  1.15999999998280200e-01;
	S->w[18] =  2.00000019216968470e-03;
	S->w[19] =  2.53026916584754180e-01;
	S->w[20] =  5.20000000000650430e-02;
	S->w[21] = -4.89999999999722740e-02;
	S->w[22] =  2.03026917499999990e-01;
	S->w[23] =  3.79999999999999990e-02;
	S->w[24] = -5.00000000000000030e-02;
	S->w[25] =  2.67026916584754300e-01;
	S->w[26] =  1.16766986351542880e-01;
	S->w[27] = -4.80387552605376840e-02;
	S->w[28] =  2.53026916584754290e-01;
	S->w[29] =  6.69999999981721880e-02;
	S->w[30] = -4.90000000000002730e-02;
	S->w[31] =  2.00000000000000010e-01;
	S->w[32] =  2.00000000000000010e-01;
	S->w[33] =  2.00000000000000010e-01;
	for(i=0;i<NDIFF;i++) S->w[i+NEQ+NPAR+1]=0.0;
}

static void SolverInitialize(SolverStruct *S)
{
	int i;

	UNUSED(i);
	i=cpr(S->w[0],&S->w[1]);
	S->w[NEQ+NPAR+1]=0.0;
	fp(NEQ,S->w[0],&S->w[1],&S->w[NEQ+NPAR+1]);
	if(IS_UNDEF(S->w[NEQ+NPAR+1])) {
		SolverError(S->w[0],0,"index-1 and derivative evaluation failure");
		return;
	}
	SolverOutputs(S);
}

/*****************************************************************************/
/* FILE fmuTemplate.c */
/*****************************************************************************/


#define FMI2_COSIMULATION
#define MODEL_GUID "{05105756-48c1-2b34-6e1c-9a6048640e26}"
#ifndef DISABLE_PREFIX
    #define FMI2_FUNCTION_PREFIX URTK_try_
#endif



/* define model size */
#define NUMBER_OF_REALS 73
#define NUMBER_OF_INTEGERS 0
#define NUMBER_OF_BOOLEANS 0
#define NUMBER_OF_STRINGS 1

/* include FMU header files, typedefs and macros */
#include "fmuTemplate.h"

/* define initial state vector and derivative vector as vectors of value references */
#define STATES {1, 2, 3, 4, 5, 6}
#define DERS   {34, 35, 36, 37, 38, 39}
#define OUTS   {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 13, 14, 15}

#ifdef FMI2_PROVIDES_DERIVATIVES
#define NIKNO 0
#define NIUNK 0
#define IKNOS { }
#define IUNKS { }
#endif

/*****************************************************************************/

#if NDIFF>0
fmi2ValueReference vrStates[NDIFF] = STATES;
fmi2ValueReference   vrDers[NDIFF] = DERS;
#else
fmi2ValueReference *vrStates = NULL;
fmi2ValueReference   *vrDers = NULL;
#endif

#if NOUT>0
fmi2ValueReference   vrOuts[NOUT] = OUTS;
#else
fmi2ValueReference   *vrOuts = NULL;
#endif

#ifdef FMI2_PROVIDES_DERIVATIVES
#if NIKNO>0
fmi2ValueReference   vrIknowns[NIKNO] = IKNOS;
#else
fmi2ValueReference   *vrIknowns = NULL;
#endif
#if NIUNK>0
fmi2ValueReference   vrIunknowns[NIUNK] = IUNKS;
#else
fmi2ValueReference   *vrIunknowns = NULL;
#endif
#endif

/*****************************************************************************
 * BEGIN: Private functions
 *****************************************************************************/
/*****************************************************************************/
static fmi2Boolean invalidNumber(ModelInstance*	comp,
								 const char*	f,
								 const char*	arg,
								 int			n,
								 int			nExpected) {
	if (n != nExpected) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = %d. Expected %d.",
			f, arg, n, nExpected);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean invalidState(ModelInstance*	comp,
								const char*		f,
								int				statesExpected) {
	if (!comp) return fmi2True;
	if (!(comp->state && statesExpected)) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal call sequence.", f);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean nullPointer(	ModelInstance*	comp,
								const char*		f,
								const char*		arg,
								const void*		p) {
	if (!p) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Invalid argument %s = NULL.", f, arg);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
static fmi2Boolean vrOutOfRange(ModelInstance*		comp,
								const char*			f,
								fmi2ValueReference	vr,
								int					end) {
	if ((int)vr >= end) {
		comp->state = modelError;
		compLog(compEnv, comp->instanceName, fmi2Error,
			"error", "[%s]: Illegal value reference %u.", f, vr);
		return fmi2True;
	}
	return fmi2False;
}
/*****************************************************************************/
void logMessage(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, errorString);
}
/*****************************************************************************/
void logWarning(ModelInstance*	comp,
				const char*		f,
				const char*		e,
				fmi2Status		value) {
	compLog(compEnv, comp->instanceName, value,
			e, "[%s]: %s", f, warningString);
}
/*****************************************************************************/
static void setVidError(ModelInstance *comp, char *errstr)
{
	if (errstr)
		strcpy(comp->viderror,errstr);
	else if (errorOccured)
		strcpy(comp->viderror,errorString);
	else
		strcpy(comp->viderror,"unknown error");
	comp->vidsts = -1;
}
/*****************************************************************************/
fmi2Status syncModel(ModelInstance *c, const char *f)
{
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (comp->state==modelInitialized && !comp->synced) {
		if(comp->initializeMode) {
			if(comp->S.wset) {
				SolverSetup(&(comp->S));
				for(i=0;i<NUMBER_OF_REALS;i++)
					if(!IS_UNDEF(comp->S.wset[i]))
						comp->S.w[i]=comp->S.wset[i];
			}
			SolverInitialize(&(comp->S));
			if (errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr, NULL);
					comp->fptr = NULL;
				}
				comp->state = modelTerminated;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Error;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		else {
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				for(i=NDIFF+1;i<=NDIFF+NIX1-NINP-NINPD;i++)
					comp->S.w[i]=comp->S.wset[i];
			SolverUpdate(&(comp->S),0,0);
			if(errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				errorOccured=0;
				logMessage(comp, f, "error", fmi2Error);
				return fmi2Discard;
			}
			else if(errorOccured<0) {
				logMessage(comp, f, "warning", fmi2Warning);
				errorOccured=0;
			}
		}
		if(inputchange) inputchange=0;
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}

/*****************************************************************************
 * END: Private functions
 *****************************************************************************/
/*****************************************************************************
 * Common functions: for FMI Model Exchange 2.0 and for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2GetTypesPlatform */
const char* fmi2GetTypesPlatform() {
	return fmi2TypesPlatform;
}
/* END: fmi2GetTypesPlatform */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetVersion */
const char* fmi2GetVersion() {
	return fmi2Version;
}
/* END: fmi2GetVersion */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetDebugLogging */
fmi2Status fmi2SetDebugLogging(	fmi2Component	c,
								fmi2Boolean		loggingOn,
								size_t			nCategories,
								const fmi2String categories[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetDebugLogging", not_modelError))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2SetDebugLogging: loggingOn = %d", loggingOn);
	if(nCategories>0 && categories!=NULL)
		/* No support for separate logging categories at this time */
		comp->loggingOn = fmi2True;
	else
		comp->loggingOn = loggingOn;
	return fmi2OK;
}
/* END: fmi2SetDebugLogging */
/*****************************************************************************/

static char nameME[] = "ModelExchange";
static char nameCS[] = "CoSimulation";
static char binfile[] = "DISABLED";

/*****************************************************************************/
/* BEGIN: fmi2Instantiate */
fmi2Component fmi2Instantiate(	fmi2String					instanceName,
								fmi2Type					fmuType,
								fmi2String					GUID,
								fmi2String					fmuLocation,
								const fmi2CallbackFunctions* functions,
								fmi2Boolean					visible,
								fmi2Boolean					loggingOn) {
	ModelInstance* comp;
	char * fname;
	fmi2String iname;
	int i;

	UNUSED(fmuLocation);
	UNUSED(visible);
	if (fmuType==fmi2ModelExchange)
		fname = nameME;
	else
		fname = nameCS;

	if (!functions->logger)
		return NULL;
	if (!functions->allocateMemory || !functions->freeMemory) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Callback function is not found.", fname);
		return NULL;
	}
	if (!instanceName || strlen(instanceName)==0) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Instance name is not found.", fname);
		return NULL;
	}
	if (strcmp(GUID, MODEL_GUID)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Inconsistent GUID %s. Expected %s.",
				fname, GUID, MODEL_GUID);
		return NULL;
	}

	comp = (ModelInstance *)functions->allocateMemory(1,sizeof(ModelInstance));

	iname = functions->allocateMemory(strlen((char*)instanceName) + 1,sizeof(char));
	if (!iname)
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
	strcpy((char*)iname, (char*)instanceName);

	if (comp) {
		comp->S.w = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		if (fmuType==fmi2ModelExchange)
			comp->S.wset = functions->allocateMemory(NUMBER_OF_REALS,sizeof(fmi2Real));
		else
			comp->S.wset = NULL;
		if(NCON>0)
			comp->S.psto = functions->allocateMemory(NDIFF*(1+NCON+2*NDIFF),sizeof(fmi2Real));
		else
			comp->S.psto = NULL;
		if(SSTO>0)
			comp->S.ssto = functions->allocateMemory(NDFA*(NDFA+1),sizeof(fmi2Real));
		else
			comp->S.ssto = NULL;
#ifdef FMI2_PROVIDES_DERIVATIVES
		if( (1+NDIFF+NINP)*(NDIFF+NOUT)>0 ) {
			comp->Jacobian = functions->allocateMemory((1+NDIFF+NINP)*(NDIFF+NOUT),sizeof(fmi2Real));
			if (!comp->Jacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->Jacobian = NULL;

		if( NIUNK*NIKNO>0 ) {
			comp->initJacobian = functions->allocateMemory(NIUNK*NIKNO,sizeof(fmi2Real));
			if (!comp->initJacobian) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initJacobian = NULL;

		if( NIUNK>0 ) {
			comp->initRes = functions->allocateMemory(NIUNK,sizeof(fmi2Real));
			if (!comp->initRes) {
				functions->logger(NULL, instanceName, fmi2Error,
						"error", "[%s]: Cannot allocate memory.", fname);
				return NULL;
			}
		}
		else
			comp->initRes = NULL;

#else
		comp->Jacobian = NULL;
		comp->initJacobian = NULL;
		comp->initRes = NULL;
#endif
		if (NUMBER_OF_INTEGERS > 0)
			comp->S.iw = functions->allocateMemory(NUMBER_OF_INTEGERS,sizeof(M_INT));
		else
			comp->S.iw = NULL;
		if (NUMBER_OF_BOOLEANS > 0)
			comp->b = functions->allocateMemory(NUMBER_OF_BOOLEANS,sizeof(fmi2Boolean));
		else
			comp->b = NULL;
		if (NUMBER_OF_STRINGS > 0) {
			comp->s = functions->allocateMemory(NUMBER_OF_STRINGS,sizeof(fmi2String));
			for (i=0; i<NUMBER_OF_STRINGS; i++)
				comp->s[i] = NULL;
		}
		else
			comp->s = NULL;
	}

	if (!comp || !comp->S.w ||	(NUMBER_OF_INTEGERS>0 && !comp->S.iw ) ||
								(NUMBER_OF_BOOLEANS>0 && !comp->b) ||
								(NUMBER_OF_STRINGS>0  && !comp->s)) {
		functions->logger(NULL, instanceName, fmi2Error,
				"error", "[%s]: Cannot allocate memory.", fname);
		return NULL;
	}

	comp->instanceName	= iname;
	comp->GUID			= MODEL_GUID;
	comp->fmuType		= fmuType;
	memcpy(&comp->functions,functions,sizeof(fmi2CallbackFunctions));
	comp->loggingOn		= loggingOn;

	if(comp->S.wset) {
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
		comp->synced			= fmi2False;
		comp->jsynced			= fmi2False;
	}
	else {
		SolverSetup(&(comp->S));
		comp->synced			= fmi2True;
		comp->jsynced			= fmi2True;
	}

	comp->initializeMode	= fmi2False;
	comp->state				= modelInstantiated;
	comp->vidsts			= 0;
	comp->minSampleStep	= minsamplestep;
	comp->fptr				= NULL;
	if (strcmp(binfile,"DISABLED") == 0)
		comp->fstr = NULL;
	else {
		comp->fstr = binfile;
		comp->s[0] = comp->functions.allocateMemory(1+strlen(binfile),sizeof(char));
		strcpy((char*)comp->s[0],(char*)binfile);
	}

	if (comp->loggingOn)
		compLog(compEnv, instanceName, fmi2OK,
			"log", "[%s]: GUID = %s", fname, GUID);

	return comp;
}
/* END: fmi2Instantiate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeInstance */
/*****************************************************************************/
void fmi2FreeInstance(fmi2Component c) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (!comp) return;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2FreeInstance");

	if (comp->instanceName)	comp->functions.freeMemory((char*)comp->instanceName);
	if (comp->S.w)			comp->functions.freeMemory(comp->S.w);
	if (comp->S.iw)			comp->functions.freeMemory(comp->S.iw);
	if (comp->S.wset)			comp->functions.freeMemory(comp->S.wset);
	if (comp->S.psto)			comp->functions.freeMemory(comp->S.psto);
	if (comp->S.ssto)			comp->functions.freeMemory(comp->S.ssto);
	if (comp->b)			comp->functions.freeMemory(comp->b);
	if (comp->Jacobian)		comp->functions.freeMemory(comp->Jacobian);
	if (comp->initRes)		comp->functions.freeMemory(comp->initRes);
	if (comp->initJacobian)		comp->functions.freeMemory(comp->initJacobian);
	if (comp->s) {
		for (i=0; i<NUMBER_OF_STRINGS; i++)
			if (comp->s[i]) comp->functions.freeMemory((char*)comp->s[i]);
		comp->functions.freeMemory((char*)comp->s);
	}

	comp->functions.freeMemory(comp);
}
/* END: fmi2FreeInstance */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetupExperiment */
/*****************************************************************************/
fmi2Status fmi2SetupExperiment(	fmi2Component	c,
								fmi2Boolean		toleranceDefined,
								fmi2Real		tolerance,
								fmi2Real		startTime,
								fmi2Boolean		stopTimeDefined,
								fmi2Real		stopTime) {
	ModelInstance* comp = (ModelInstance *)c;

	UNUSED(toleranceDefined);
	UNUSED(tolerance);
	comp->S.w[0]	= startTime;
	comp->startTime	= startTime;

	if (stopTimeDefined)
		comp->stopTime = stopTime;
	else
		comp->stopTime = 0.0;

	comp->stopTimeDefined = stopTimeDefined;

	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}
	if (comp->fstr && strcmp(comp->fstr,"DISABLED")!=0
						&& strcmp(comp->fstr,"'DISABLED'")!=0 )
		comp->fptr = fopen(comp->fstr,"wb");

	comp->lastsampletime = -1e10;
	comp->lastStepSize = -1.0;
	comp->lastSuccessfulTime = startTime;
	comp->numpts = 0;
	comp->vidsts = 0;
	comp->vidlasttime = -1e10;

	return fmi2OK;
}
/* END: fmi2SetupExperiment */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterInitializationMode */
fmi2Status fmi2EnterInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2EnterInitializationMode", modelInstantiated))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2EnterInitializationMode");

	/* Do not sync here - delay the sync until the first FMU query */
	comp->synced			= fmi2False;
	comp->jsynced			= fmi2False;

	comp->initializeMode	= fmi2True;
	comp->state				= modelInitialized;
	comp->vidsts			= 1;
	if (comp->fptr) {
		fwrite(nData,sizeof(fmi2Real),2,comp->fptr);
		if(NPAR>0) {
			syncModel(c,"fmi2EnterInitializationMode");
			fwrite(&comp->S.w[NEQ+1],sizeof(fmi2Real),NPAR,comp->fptr);
		}
	}

	return fmi2OK;
}
/* END: fmi2EnterInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ExitInitializationMode */
fmi2Status fmi2ExitInitializationMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	fmi2Status sts;
	int i;

	if (comp) {
		sts = syncModel(c,"fmi2ExitInitializationMode");
		if ( sts!=fmi2OK ) return(sts);
		comp->initializeMode = fmi2False;
		if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
			for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
				comp->S.wset[i]=comp->S.w[i];
		comp->jsynced =fmi2False;
		comp->vidsts = 2;
		if (comp->fptr)
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2ExitInitializationMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Terminate */
fmi2Status fmi2Terminate(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Terminate", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Terminate");
	if (comp->fptr) {
		fclose(comp->fptr);
		comp->fptr = NULL;
	}

	comp->state = modelTerminated;

	return fmi2OK;
}
/* END: fmi2Terminate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Reset */
fmi2Status fmi2Reset(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState(comp, "fmi2Reset", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK,
			"log", "fmi2Reset");

	comp->state = modelInstantiated;
	comp->synced = fmi2False;
	comp->jsynced = fmi2False;

	if(comp->S.wset)
		for(i=0;i<NUMBER_OF_REALS;i++)
			comp->S.wset[i]=1.0/dsn_zero;
	else
		SolverSetup(&(comp->S));

	return fmi2OK;
}
/* END: fmi2Reset */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetReal */
fmi2Status fmi2GetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2Real				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetReal", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetReal", "value[]", value))
		return fmi2Error;

#if NUMBER_OF_REALS+1>0
	/*for (i=0; i<(int)nvr; i++)
		if (vrOutOfRange(comp, "fmi2GetReal", vr[i], NUMBER_OF_REALS))
		return fmi2Error;*/

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetReal");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrStates[0]];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			value[i] = comp->S.w[vr[i]]/nomfac[vr[i]-vrDers[0]];
		else if (vr[i] == 73)
			value[i] = comp->minSampleStep;
		else if (vr[i] > NUMBER_OF_REALS) {
			comp->state = modelError;
            compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2GetReal", vr[i]);
            return fmi2Error;
		}
		else
			value[i] = comp->S.w[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetReal: #r%u# = %.16g", vr[i], value[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetInteger */
fmi2Status fmi2GetInteger(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Integer				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetInteger", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetInteger", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetInteger");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		value[i] = (fmi2Integer)comp->S.iw[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetInteger: #i%u# = %d", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBoolean */
fmi2Status fmi2GetBoolean(	fmi2Component			c,
							const fmi2ValueReference vr[],
							size_t					nvr,
							fmi2Boolean				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBoolean", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetBoolean", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetBoolean");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2GetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		value[i] = comp->b[vr[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK,
				"log", "fmi2GetBoolean: #b%u# = %s",vr[i], value[i]? "true":"false");
	}
	return fmi2OK;
}
/* END: fmi2GetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetString */
fmi2Status fmi2GetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						fmi2String				value[]) {
	int i;
	fmi2Status sts;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetString", validGet))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2GetString", "value[]", value))
		return fmi2Error;

	if(comp->state != modelTerminated) {
		sts = syncModel(comp,"fmi2GetString");
		if ( sts!=fmi2OK ) return sts;
	}

	for (i=0; i<(int)nvr; i++) {
		if (vr[i] == 74)
			value[i] = comp->s[0];
		else {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2GetString", vr[i]);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetString: #s%u# = '%s'", vr[i], value[i]);
	}
	return fmi2OK;
}
/* END: fmi2GetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetReal */
fmi2Status fmi2SetReal(	fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Real			value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;
	double scalev;

	if (invalidState(comp, "fmi2SetReal", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetReal", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log",
				"fmi2SetReal: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetReal", vr[i], NUMBER_OF_REALS+1))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetReal: #r%d# = %.16g", vr[i], value[i]);
		if( nomfac && vr[i]>=vrStates[0] && vr[i]<vrStates[0]+NDIFF )
			scalev = nomfac[vr[i]-vrStates[0]]*value[i];
		else if( nomfac && vr[i]>=vrDers[0] && vr[i]<vrDers[0]+NDIFF )
			scalev = nomfac[vr[i]-vrDers[0]]*value[i];
		else if (vr[i] == 73) {
			comp->minSampleStep = value[i];
			continue;
		}
		else
			scalev = value[i];
		if (comp->S.w[vr[i]]!=scalev) {
#if NINP>0
			if(vr[i]>=1+NDIFF+NIX1-NINP && vr[i]<1+NDIFF+NIX1)
				inputchange=1;
#endif
#if NPAR>0
			if(comp->state==modelInitialized && comp->initializeMode==fmi2False
				&& vr[i]>=1+NEQ && vr[i]<=1+NEQ+NPAR) {
				if(pflags[vr[i]-1-NEQ])
					pchange=1;
				else {
					compLog(NULL, comp->instanceName, fmi2Error, "error",
						"fmi2SetReal: attempt to change fixed parameter after initialization.");
					return fmi2Error;
				}
			}
#endif
			comp->S.w[vr[i]] = scalev;
			if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
				comp->S.wset[vr[i]] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetReal */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetInteger */
fmi2Status fmi2SetInteger(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Integer		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetInteger", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetInteger", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetInteger: nvr = %d",
				nvr);

	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetInteger", vr[i], NUMBER_OF_INTEGERS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log", "fmi2SetInteger: #i%d# = %d", vr[i], value[i]);
		if (comp->S.iw[vr[i]]!=(M_INT)value[i]) {
			comp->S.iw[vr[i]] = (M_INT)value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetInteger */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetBoolean */
fmi2Status fmi2SetBoolean(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2Boolean		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetBoolean", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetBoolean", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetBoolean: nvr = %d", nvr);
	for (i=0; i<(int)nvr; i++) {
		if (vrOutOfRange(comp, "fmi2SetBoolean", vr[i], NUMBER_OF_BOOLEANS))
			return fmi2Error;
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetBoolean: #b%d# = %s",
					vr[i], value[i] ? "true" : "false");
		if (comp->b[vr[i]]!=value[i]) {
			comp->b[vr[i]] = value[i];
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}

	return fmi2OK;
}
/* END: fmi2SetBoolean */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetString */
fmi2Status fmi2SetString(fmi2Component			c,
						const fmi2ValueReference vr[],
						size_t					nvr,
						const fmi2String		value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetString", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "vr[]", vr))
		return fmi2Error;
	if (nvr>0 && nullPointer(comp, "fmi2SetString", "value[]", value))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName,
				fmi2OK, "log", "fmi2SetString: nvr = %d",	nvr);

	for (i=0; i<(int)nvr; i++) {
		char* string = (char*)comp->s[0];
		if (vr[i] != 74) {
			comp->state = modelError;
			compLog(compEnv, comp->instanceName, fmi2Error,
					"error", "[%s]: Illegal value reference %u.", "fmi2SetString", vr);
			return fmi2Error;
		}
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName,
					fmi2OK, "log",
					"fmi2SetString: #s%d# = '%s'",
					vr[i], value[i]);
		if (nullPointer(comp, "fmi2SetString", "value[i]", value[i]))
			return fmi2Error;
		if (string==NULL || strlen(string) < strlen(value[i])) {
			if (string) comp->functions.freeMemory(string);
			comp->s[0] = comp->functions.allocateMemory(1+strlen(value[i]),
															sizeof(char));
			if (!comp->s[0]) {
				comp->state = modelError;
				compLog(NULL, comp->instanceName,
						fmi2Error, "error", "fmi2SetString: Out of memory.");
				return fmi2Error;
			}
		}
		strcpy((char*)comp->s[0], (char*)value[i]);
		/*comp->synced = fmi2False;*/
		if (vr[i] == 74)
			comp->fstr = comp->s[0];
	}

	return fmi2OK;
}
/* END: fmi2SetString */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetFMUstate */
/*****************************************************************************/
/* Storage structure:
		State id (hard coded value)
		Data length (bytes)
		ModelInstance
		Real data storage
		Integer data storage
		Real backup data storage (only for ME)
		Jacobian storage
		Error code
		String storage
*/
#define FMUStateID 983472598

fmi2Status fmi2GetFMUstate (
	fmi2Component	c,
	fmi2FMUstate*	FMUstate
)
{
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2Real *rcur;
	M_INT i,j,*icur,wsto,ssto,jsto,totsto;

	if (invalidState(comp, "fmi2GetFMUstate", modelInitialized))
		return fmi2Error;

	if(comp->fmuType==fmi2ModelExchange)
		wsto = NUMBER_OF_REALS*sizeof(fmi2Real);
	else
		wsto = 0;

#ifdef FMI2_PROVIDES_DERIVATIVES
	jsto=( (1+NDIFF+NINP)*(NDIFF+NOUT) + NIUNK*(NIKNO+1) )*sizeof(fmi2Real);
#else
	jsto=0;
#endif

	ssto=0;
	for(i=0;i<NUMBER_OF_STRINGS;i++)
		if(comp->s[i])
			ssto+=strlen(comp->s[i])+1;
		else
			ssto++;

	totsto = 2*sizeof(M_INT) +
				sizeof(ModelInstance) +
				NUMBER_OF_REALS*sizeof(fmi2Real) +
				NUMBER_OF_INTEGERS*sizeof(M_INT) +
				wsto +
				jsto +
				sizeof(M_INT) +
				ssto;

	/* Verify that previously allocated FMU state is of sufficient size */
	if(*FMUstate) {
		icur=(M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID) {
			/* FMUstate pointer is not previously allocated in this routine
				so no way to verify the size */
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2GetFMUstate: called with non-NULL state pointer of unknown size. Assuming sufficiently large.");
		}
		else if(icur[1]<totsto) {
			comp->functions.freeMemory(*FMUstate);
			*FMUstate=NULL;
		}
	}

	if(*FMUstate==NULL)
		FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,totsto);

	cur = (char *)(*FMUstate);

	icur = (M_INT *)cur;
	icur[0] = FMUStateID;
	icur[1] = totsto;
	cur += 2*sizeof(M_INT);

	memcpy(cur,comp,sizeof(ModelInstance));
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.w[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) icur[i] = comp->S.iw[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real*)cur;
		for (i=0;i<NUMBER_OF_REALS;i++)	rcur[i] = comp->S.wset[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	rcur[i] = comp->Jacobian[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	rcur[i] = comp->initJacobian[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	rcur[i] = comp->initRes[i];
	cur += NIUNK*sizeof(fmi2Real);
#endif

	icur = (M_INT *)cur;
	icur[0] = errorOccured;
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		if(comp->s[i]) {
			for(j=0;comp->s[i][j]!='\0';j++)
				*(cur++)=comp->s[i][j];
		}
		*(cur++)='\0';
	}

	return fmi2OK;
}
/* END: fmi2GetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetFMUstate */
/*****************************************************************************/
fmi2Status fmi2SetFMUstate (fmi2Component	c,
							fmi2FMUstate	FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	char *cur;
	fmi2String *scur;
	fmi2Real *rcur,*wcur,*jcur1,*jcur2,*jcur3;
	M_INT i,j,l,*icur;

	if (invalidState(comp, "fmi2SetFMUstate", modelInitialized))
		return fmi2Error;

	cur = (char *)FMUstate;
	icur = (M_INT *)cur;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SetFMUstate: called with invalid FMUstate");
		return(fmi2Error);
	}
	cur += 2*sizeof(M_INT);

	rcur = comp->S.w;
	icur = comp->S.iw;
	wcur = comp->S.wset;
	jcur1 = comp->Jacobian;
	jcur2 = comp->initJacobian;
	jcur3 = comp->initRes;
	scur = comp->s;
	memcpy(comp,cur,sizeof(ModelInstance));
	comp->S.w  = rcur;
	comp->S.iw = icur;
	comp->S.wset = wcur;
	comp->Jacobian = jcur1;
	comp->initJacobian = jcur2;
	comp->initRes = jcur3;
	comp->s = scur;
	cur += sizeof(ModelInstance);

	rcur = (fmi2Real *)cur;
	for(i=0;i<NUMBER_OF_REALS;i++) comp->S.w[i] = rcur[i];
	cur += NUMBER_OF_REALS*sizeof(fmi2Real);

	icur = (M_INT *)cur;
	for (i=0;i<NUMBER_OF_INTEGERS;i++) comp->S.iw[i] = icur[i];
	cur += NUMBER_OF_INTEGERS*sizeof(M_INT);

	if(comp->fmuType==fmi2ModelExchange) {
		rcur = (fmi2Real *)cur;
		for(i=0;i<NUMBER_OF_REALS;i++) comp->S.wset[i] = rcur[i];
		cur += NUMBER_OF_REALS*sizeof(fmi2Real);
	}
	else
		comp->S.wset = NULL;

#ifdef FMI2_PROVIDES_DERIVATIVES
	rcur = (fmi2Real*)cur;
	for (i=0;i<(1+NDIFF+NINP)*(NDIFF+NOUT);i++)	comp->Jacobian[i] = rcur[i];
	cur += (1+NDIFF+NINP)*(NDIFF+NOUT)*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK*NIKNO;i++)	comp->initJacobian[i] = rcur[i];
	cur += NIUNK*NIKNO*sizeof(fmi2Real);

	rcur = (fmi2Real*)cur;
	for (i=0;i<NIUNK;i++)	comp->initRes[i] = rcur[i];
	cur += NIUNK*sizeof(fmi2Real);
#else
	comp->Jacobian = NULL;
	comp->initJacobian = NULL;
	comp->initRes = NULL;
#endif

	icur = (M_INT *)cur;
	errorOccured = icur[0];
	cur += sizeof(M_INT);

	for(i=0;i<NUMBER_OF_STRINGS;i++) {
		l=(comp->s[i]) ? strlen(comp->s[i]) : 0;
		j=strlen(cur);
		if(j>l) {
			if(comp->s[i]) comp->functions.freeMemory((char *)comp->s[i]);
			comp->s[i]=(fmi2String)comp->functions.allocateMemory(1,j+1);
		}
		strcpy((char *)comp->s[i],cur);
		cur += j+1;
	}

	return fmi2OK;
}
/* END: fmi2SetFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2FreeFMUstate */
/*****************************************************************************/
fmi2Status fmi2FreeFMUstate(fmi2Component c,
							fmi2FMUstate* FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2FreeFMUstate",
		modelInstantiated|modelInitialized|modelTerminated|modelError))
		return fmi2Error;

	if( *FMUstate ) {
		icur = (M_INT *)(*FMUstate);
		if(icur[0]!=FMUStateID)
			compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
				"fmi2FreeFMUstate: called with invalid FMUstate");
		comp->functions.freeMemory(*FMUstate);
	}

	*FMUstate = NULL;

	return fmi2OK;
}
/* END: fmi2FreeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializedFMUstateSize */
/*****************************************************************************/
fmi2Status fmi2SerializedFMUstateSize(	fmi2Component	c,
										fmi2FMUstate	FMUstate,
										size_t			*size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializedFMUstateSize", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstateSize: called with invalid FMUstate");
		return(fmi2Error);
	}
	*size = (size_t)icur[1];

	return fmi2OK;
}
/* END: fmi2SerializedFMUstateSize */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2SerializeFMUstate(fmi2Component		c,
								fmi2FMUstate		FMUstate,
								fmi2Byte 			serializedState[],
								size_t				size) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2SerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)FMUstate;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with invalid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain FMUstate");
		return fmi2Error;
	}
	memcpy(serializedState, FMUstate, size);

	return fmi2OK;
}
/* END: fmi2SerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2DeSerializeFMUstate */
/*****************************************************************************/
fmi2Status fmi2DeSerializeFMUstate(	fmi2Component	c,
									const fmi2Byte	serializedState[],
									size_t			size,
									fmi2FMUstate	*FMUstate) {
	ModelInstance* comp = (ModelInstance *)c;
	M_INT *icur;

	if (invalidState(comp, "fmi2DeSerializeFMUstate", modelInitialized))
		return fmi2Error;

	icur = (M_INT *)serializedState;
	if(icur[0]!=FMUStateID) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2DeSerializedFMUstate: called with serializedState not containing valid FMUstate");
		return fmi2Error;
	}
	if(icur[1]>(M_INT)size) {
		compLog(compEnv, comp->instanceName, fmi2Error, "error",
			"fmi2SerializedFMUstate: called with size not sufficient to contain serializedState");
		return fmi2Error;
	}
	FMUstate[0] = (fmi2FMUstate)comp->functions.allocateMemory(1,size);
	memcpy(*FMUstate, serializedState, size);

	return fmi2OK;
}
/* END: fmi2DeSerializeFMUstate */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDirectionalDerivative */
/*****************************************************************************/
fmi2Status fmi2GetDirectionalDerivative(	fmi2Component			c,
										const fmi2ValueReference	vUnknown_ref[],
										size_t						nUnknown,
										const fmi2ValueReference	vKnown_ref[],
										size_t						nKnown,
										const fmi2Real				dvKnown[],
										fmi2Real					dvUnknown[]) {
#ifdef FMI2_PROVIDES_DERIVATIVES
	int i, j, k, row, col, offset;
	fmi2Status sts;
	fmi2ValueReference vrs, vrd;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetDirectionalDerivatives", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vKnown_ref[]", vKnown_ref))
		return fmi2Error;
	if (nUnknown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "vUnknown_ref[]", vUnknown_ref))
		return fmi2Error;
	if (nKnown>0 && nullPointer(comp, "fmi2GetDirectionalDerivative", "dvKnown[]", dvKnown))
		return fmi2Error;

	sts = syncModel(comp,"fmi2GetDirectionalDerivative");
	if ( sts!=fmi2OK ) return sts;

	/* Initialize unknown vector */
	for (i=0; i<nUnknown; i++) dvUnknown[i] = 0.;

	/* Get Jacobian information, dimensions, data, etc? */
	if(!comp->jsynced) {
		if(comp->initializeMode)
			initjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->initRes,comp->initJacobian);
		else
			intjac(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),comp->Jacobian);
		comp->jsynced = fmi2True;
	}

	/* Order of value references :
	t, #states, #index-1(inps), #discrete, #params, #derivs, #events */

	/* Start the computation loop */
	if (comp->initializeMode) {
		offset = NIKNO;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				col = -1;
				for (k=0; k<NIKNO; k++)
					if (vrs==vrIknowns[k]) {
						col = k;
						break;
					}
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					if ( vrd==vrs ) {
						dvUnknown[j] += 1.0;
					}
					else if(col!=-1) {
						for (k=0; k<NIUNK; k++)
							if (vrd==vrIunknowns[k]) {
								dvUnknown[j] += dvKnown[i]*comp->initJacobian[k*offset+col];
								break;
							}
					}
				}
			}
		}
	}
	else {
		offset = 1+NDIFF+NINP;
		for (i=0; i<nKnown; i++) {
			/* Check the seed */
			if (dvKnown[i]!=0) {
				vrs = vKnown_ref[i];
				/* assert(vr>=0 && vr<NUMBER_OF_REALS); */
				/* Check that vKnown_ref[i] is a state or input */
				if ( vrs==0 || (vrs>=vrStates[0] && vrs<vrStates[0]+NDIFF) )
					col = vrs;
				else if(vrs>=1+NDIFF+NIX1-NINP && vrs<1+NDIFF+NIX1)
					col = vrs-(NIX1-NINP);
				else
					return fmi2Error;
				/* Compute column i */
				for (j=0; j<nUnknown; j++) {
					vrd = vUnknown_ref[j];
					/* assert(vrd>=0 && vrd<NUMBER_OF_REALS); */
					/* Check if vrd is a derivative or an output,
					it could also be an output that's a state */
					if ( vrd>=vrDers[0] && vrd<vrDers[0]+NDIFF ) {
						row = vrd-vrDers[0];
						dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
					}
					else if( vrd>=vrStates[0] && vrd<vrStates[0]+NDIFF ) {
						if ( vrd==vrs ) dvUnknown[j] += 1.0;
					}
					else {
						for (k=0; k<NOUT; k++)
							if (vrd==vrOuts[k]) {
								/* refval-t-states+derivs: vrd-1-NDIFF+NDIFF */
								row = vrd-1;
								dvUnknown[j] += dvKnown[i]*comp->Jacobian[row*offset+col];
								break;
							}
						if (k==NOUT) return fmi2Error;
					}
				}
			}
		}
	}
	return fmi2OK;
#else
	/* Compiler warning fix */
	int i=nUnknown+nKnown;
	void *tmp;
	tmp=(void *)vUnknown_ref;
	tmp=(void *)vKnown_ref;
	tmp=(void *)dvKnown;
	tmp=(void *)dvUnknown;
	if(i>0) tmp=(void *)c;
	i=((int *)tmp)[0];
	/* End compiler warning fix */
	return fmi2Error;
#endif
}
/* END: fmi2GetDirectionalDerivative */
/*****************************************************************************/

#if NCON>0 && defined(WMI_PROJECTION)
/*****************************************************************************/
/* BEGIN: fmi2Projection */
/*****************************************************************************/
fmi2Status fmi2Projection(	fmi2Component	c,
								fmi2Real	P[],
								fmi2Real	projectionTolerance,
								size_t	iterationLimit,
								fmi2Boolean	apply) {
	int i;
	fmi2Status sts;
	fmi2Real S2[NDIFF];

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Projection", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Projection");
	if ( sts!=fmi2OK ) return sts;

	for(i=0;i<NDIFF;i++) S2[i] = comp->S.w[i+1];
	i=Projection(comp->S.w[0], &comp->S.w[1], projectionTolerance,
		iterationLimit, NULL, comp->S.psto);
	if( i!=0 ){
		/* Restore state */
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
		return fmi2Discard;
	}
	for(i=0;i<NDIFF;i++) P[i] = comp->S.w[i+1]-S2[i];

	if( !apply ){
		for(i=0;i<NDIFF;i++) comp->S.w[i+1]=S2[i];
	}

	return fmi2OK;
}
/* END: fmi2Projection */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ProjectionStep: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ProjectionStep(  fmi2Component	c,
								fmi2Real	S[]) {
	UNUSED(c);
	UNUSED(S);
	return fmi2Error;
}
/* END: fmi2ProjectionStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2Constraint */
/*****************************************************************************/
fmi2Status fmi2Constraint(	fmi2Component	c,
								fmi2Real	C[]) {
	int cb, cr, nblk;
	fmi2Real blkdata[2];
	fmi2Status sts;

	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2Constraint", modelInstantiated|modelInitialized))
		return fmi2Error;

	sts = syncModel(comp,"fmi2Constraint");
	if ( sts!=fmi2OK ) return sts;

	/* Iterate over Residual blocks */
	Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, 0, 0);
	nblk = (int)(blkdata[0]);
	cr = 0;
	for(cb=1;cb<=nblk;cb++) {
		Rblkp(comp->S.w[0], &comp->S.w[1], &C[cr], cb, 3);
		Rblkp(comp->S.w[0], &comp->S.w[1], blkdata, cb, 1);
		cr += (int)(blkdata[0]);
	}

	return fmi2OK;
}
/* END: fmi2Constraint */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2ConstraintJacobian: No longer supported */
/*****************************************************************************/
fmi2Status fmi2ConstraintJacobian(	fmi2Component	c,
										fmi2Real	J[]) {

	/* If this function is required at some point, the code will need to be
	modified to fill in the ncon x ndiff Matrix using a sequence of calls to
	the block-based Jacobian. It is known that this will provide 0 entries
	for block dependencies on vars from a prior block, but this will only
	slow convergence of a newton approach, and be irrelevant when sufficiently
	close to the solution manifold */
	UNUSED(c);
	UNUSED(J);
	return fmi2Error;
}
/* END: fmi2ConstraintJacobian */
/*****************************************************************************/
#endif

#ifdef FMI2_COSIMULATION
/*****************************************************************************
 * FMI functions: only for FMI Co-Simulation 2.0
 *****************************************************************************/
/*****************************************************************************/
/* BEGIN: fmi2SetRealInputDerivatives */
fmi2Status fmi2SetRealInputDerivatives(	fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										const fmi2Real			value[]) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2SetRealInputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetRealInputDerivatives: nvr= %d", nvr);

	UNUSED(vr);
	UNUSED(order);
	UNUSED(value);
	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2SetRealInputDerivatives: ignoring function call."
			" This model cannot interpolate inputs: canInterpolateInputs = \"fmi2False\"");

	return fmi2Warning;
}
/* END: fmi2SetRealInputDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealOutputDerivatives */
fmi2Status fmi2GetRealOutputDerivatives(fmi2Component			c,
										const fmi2ValueReference vr[],
										size_t					nvr,
										const fmi2Integer		order[],
										fmi2Real				value[]) {
	int i;
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealOutputDerivatives", modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetRealOutputDerivatives: nvr= %d",	nvr);

	UNUSED(vr);
	UNUSED(order);
	compLog(NULL, comp->instanceName, fmi2Error, "warning",
			"fmi2GetRealOutputDerivatives: ignoring function call."
			" This model cannot compute derivatives of outputs: MaxOutputDerivativeOrder=\"0\"");

	for (i=0; i<(int)nvr; i++) value[i] = 0;

	return fmi2Warning;
}
/* END: fmi2GetRealOutputDerivatives */
/*****************************************************************************/

#define MAX_STEP  1.00000000000000000e-03

/*****************************************************************************/
/* BEGIN: fmi2DoStep */
fmi2Status fmi2DoStep(  fmi2Component	c,
						fmi2Real		currentCommunicationPoint,
						fmi2Real		communicationStepSize,
						fmi2Boolean		newStep) {

	ModelInstance* comp	= (ModelInstance *)c;
	int		i;
	double	h;
	int		n;	/* how many internal steps to perform for one fmi2DoStep */
	int		k;
#if NEVT>0
	M_INT *modes;
	int hasEvent;
	double	prevEventIndicators[max(NEVT, 1)], eventIndicators[max(NEVT, 1)];
#endif

	if (invalidState(comp, "fmi2DoStep", modelInitialized)) return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2DoStep: "
				"currentCommunicationPoint = %g, "
				"communicationStepSize = %g, "
				"newStep = fmi2%s",
				currentCommunicationPoint, communicationStepSize, newStep ? "True" : "False");

	if (comp->stopTimeDefined && currentCommunicationPoint+communicationStepSize > comp->stopTime) {
		comp->state = modelError;
		return fmi2Error;
	}

	if(communicationStepSize==0) {
		n = 1;
		h = 0.0;
	}
	else {
		n = (int)floor((communicationStepSize-1e-12)/MAX_STEP)+1;
		h = communicationStepSize/n;
	}

#if NPAR>0
	if(pchange) {
		SolverInitialize(&(comp->S));
		pchange=0;
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
	}
#endif

#if NEVT>0
	/* Run to get initial event indicators */
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),prevEventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(prevEventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
#endif

	comp->S.w[0] = currentCommunicationPoint;
	/* break the step into n steps and do a step */
	for (k=0; k<n; k++) {
#if NUMBER_OF_REALS>0
		if (h>0.0) {
			RK4Step(h,&(comp->S));
			if (errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				comp->state = modelTerminated;
				logMessage(comp,"RK4Step","error", fmi2Error);
				return fmi2Error;
			}
			else if(errorOccured<0) {
				logMessage(comp, "RK4Step", "warning", fmi2Warning);
				errorOccured=0;
			}
		}

		SolverUpdate(&(comp->S),0,1);
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;

		i=SolverProject(&(comp->S));
		if(i<0 || errorOccured==1) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			return fmi2Error;
		}
		else if(i>0 || errorOccured==2) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2DoStep: model requested termination at t = %g",
					comp->S.w[0]);
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2DoStep", "warning", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
			errorOccured=0;
		}
#endif

#if NEVT>0
		hasEvent = 0;

		/* check for state event */
		eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),eventIndicators);
		modes=comp->S.iw;
		ComputeEventIndicators(eventIndicators,&(comp->S.w[1]),modes,
			&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
		for (i=0; i<NEVT; i++) {
			if (eventIndicators[i] * prevEventIndicators[i] < 0) {
				hasEvent = 1;
				if (comp->loggingOn)
					compLog(compEnv, comp->instanceName, fmi2OK, "log",
							"fmi2DoStep: state event at %g, z%d crosses zero -%c-",
							comp->S.w[0], i, eventIndicators[i]<0 ? '\\' : '/');
			}
			prevEventIndicators[i] = eventIndicators[i];
		}

		if (hasEvent) {
			i = RunEvents(comp->S.w, comp->S.iw, 0, -1, EVTITER, comp->S.psto);
			if (i>0 || errorOccured==2) {
				compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2DoStep: model requested termination at t = %g",
					comp->S.w[0]);
			}
			else if (i<0 || errorOccured>0) {
				logMessage(comp, "fmi2DoStep", "error", fmi2Error);
			}
			if (i || errorOccured>0) {
				setVidError(comp,NULL);
				if (comp->fptr) {
					writeErrorToFile(comp->fptr,NULL);
					comp->fptr = NULL;
				}
				errorOccured = 0;
				comp->state = modelTerminated;
				return fmi2Discard;
			}
			if(errorOccured<0) {
				logMessage(comp, "fmi2DoStep", "warning", fmi2Warning);
				errorOccured=0;
			}
		}
#endif

		SolverOutputs(&(comp->S));
	}

	comp->lastSuccessfulTime = currentCommunicationPoint + communicationStepSize;
	comp->vidsts = 2;
 	if (comp->fptr)
		fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);

	return fmi2OK;
}
/* END: fmi2DoStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CancelStep */
fmi2Status fmi2CancelStep(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2CancelStep", modelInitialized)) return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log", "fmi2CancelStep");

	compLog(NULL, comp->instanceName, fmi2Error, "error",
			"fmi2CancelStep: Can be called when fmi2DoStep returned fmi2Pending."
			" This is not the case.");
	comp->state = modelError;
	return fmi2Error;
}
/* END: fmi2CancelStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStatus */
fmi2Status fmi2GetStatus(	fmi2Component		c,
							const fmi2StatusKind s,
							fmi2Status*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStatus", modelInstantiated|modelInitialized))
		return fmi2Error;

	UNUSED(value);
	if (s==fmi2DoStepStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStatus]: fmi2StatusKind = fmi2DoStepStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetStatus]: Can be called with fmi2DoStepStatus when fmi2DoStep returned fmi2Pending."
				" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetRealStatus */
fmi2Status fmi2GetRealStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Real*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetRealStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2LastSuccessfulTime) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetRealStatus]: fmi2StatusKind = fmi2LastSuccessfulTime");
		}
		if (comp->state==modelTerminated) {
			*value = comp->lastSuccessfulTime;
			return fmi2OK;
		}
		else {
			compLog(NULL, comp->instanceName, fmi2Error, "error",
				"[fmi2GetRealStatus]: Can be called with fmi2LastSuccessfulTime when fmi2DoStep returned fmi2Discard."
				" This is not the case.");
			return fmi2Discard;
		}
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetRealStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetIntegerStatus */
fmi2Status fmi2GetIntegerStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Integer*		value) {
	UNUSED(c);
	UNUSED(s);
	UNUSED(value);
	return fmi2Discard;
}
/* END: fmi2GetIntegerStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetBooleanStatus */
fmi2Status fmi2GetBooleanStatus(fmi2Component		c,
								const fmi2StatusKind s,
								fmi2Boolean*		value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetBooleanStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	if (s==fmi2Terminated) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetBooleanStatus]: fmi2StatusKind = fmi2Terminated");
		}
		if (comp->state==modelTerminated)
			*value = fmi2True;
		else
			*value = fmi2False;
		return fmi2OK;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetBooleanStatus */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetStringStatus */
fmi2Status fmi2GetStringStatus(	fmi2Component		c,
								const fmi2StatusKind s,
								fmi2String*			value) {
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState(comp, "fmi2GetStringStatus", modelInstantiated|modelInitialized))
		return fmi2Discard;

	UNUSED(value);
	if (s==fmi2PendingStatus) {
		if (comp->loggingOn) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"[fmi2GetStringStatus]: fmi2StatusKind = fmi2PendingStatus");
			compLog(NULL, comp->instanceName, fmi2Error, "error",
					"[fmi2GetStringStatus]: Can be called with fmi2PendingStatus when fmi2DoStep returned fmi2Pending."
					" This is not the case.");
		}
		return fmi2Discard;
	}
	else
		return fmi2Discard;
}
/* END: fmi2GetStringStatus */
/*****************************************************************************/

#else
/*****************************************************************************
 * FMI functions: only for Model Exchange 2.0
 *****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterEventMode */
fmi2Status fmi2EnterEventMode(fmi2Component c) {
	ModelInstance* comp = (ModelInstance *)c;

	if (comp) {
		comp->lastEventTime = comp->S.w[0]-1.0;
		return fmi2OK;
	}
	else
		return fmi2Error;
}
/* END: fmi2EnterEventMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2NewDiscreteStates */
fmi2Status fmi2NewDiscreteStates(fmi2Component	c,
								fmi2EventInfo*	eventInfo) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NEVT+NCON>0
	fmi2Real save[NEQ],val;
#endif
	if (invalidState(comp, "fmi2NewDiscreteStates", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2NewDiscreteStates", "eventInfo", eventInfo))
		return fmi2Error;

	eventInfo->newDiscreteStatesNeeded				= fmi2False;
	eventInfo->nominalsOfContinuousStatesChanged	= fmi2False;
	eventInfo->valuesOfContinuousStatesChanged		= fmi2False;
	eventInfo->terminateSimulation					= fmi2False;
	eventInfo->nextEventTimeDefined					= fmi2False;
	eventInfo->nextEventTime						= -0.0;

#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
#endif
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#if NEVT>0
	if (comp->S.w[0]!=comp->lastEventTime) {
		i=RunEvents(comp->S.w, comp->S.iw, 0, -1, EVTITER, comp->S.psto);
		if (i<0 || errorOccured==1) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
			return fmi2Error;
		}
		else if (i>0 || errorOccured==2) {
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2NewDiscreteStates: model requested termination at t = %g",
					comp->S.w[0]);
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			eventInfo->terminateSimulation = fmi2True;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
			return fmi2OK;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->lastEventTime = comp->S.w[0];
	}
	i=RunEvents(comp->S.w, comp->S.iw, 1, -1, EVTITER, comp->S.psto);
	if (i<0 || errorOccured==1) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "error", fmi2Error);
		return fmi2Error;
	}
	else if (i>0 || errorOccured==2) {
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2NewDiscreteStates: model requested termination at t = %g",
				comp->S.w[0]);
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		eventInfo->terminateSimulation = fmi2True;
		comp->state = modelTerminated;
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Discard);
		return fmi2OK;
	}
	else if(errorOccured<0) {
		logMessage(comp, "fmi2NewDiscreteStates", "warning", fmi2Warning);
		errorOccured=0;
	}
#endif
#if NEVT+NCON>0
	for(i=0;i<NEQ;i++) {
		val=1e-15;
		if(fabs(save[i])>val) val=fabs(save[i]);
		if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
		if( fabs(comp->S.w[i+1]-save[i])>1e-12*val )
			eventInfo->valuesOfContinuousStatesChanged = fmi2True;
	}
	if(eventInfo->valuesOfContinuousStatesChanged==fmi2True)
		SolverOutputs(&(comp->S));
#endif
	return fmi2OK;
}
/* END: fmi2NewDiscreteStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2EnterContinuousTimeMode */
fmi2Status fmi2EnterContinuousTimeMode(fmi2Component c) {
	if (c)	return fmi2OK;
	else	return fmi2Error;
}
/* END: fmi2EnterContinuousTimeMode */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2CompletedIntegratorStep */
fmi2Status fmi2CompletedIntegratorStep(	fmi2Component	c,
										fmi2Boolean		noSetFMUStatePriorToCurrentPoint,
										fmi2Boolean*	enterEventMode,
										fmi2Boolean*	terminateSimulation) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;
#if NCON>0 && defined(CONDSTEPEVENT)
	fmi2Real save[NEQ],val,drift;
#endif

	UNUSED(noSetFMUStatePriorToCurrentPoint);
	if (invalidState(comp, "fmi2CompletedIntegratorStep", modelInitialized))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "enterEventMode", enterEventMode))
		return fmi2Error;
	if (nullPointer (comp, "fmi2CompletedIntegratorStep", "terminateSimulation", terminateSimulation))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2CompletedIntegratorStep");

	*terminateSimulation = fmi2False;

	if (comp->synced)
		SolverUpdate(&(comp->S),1,1);
	else {
		SolverUpdate(&(comp->S),0,1);
		if (errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured = 0;
			comp->state = modelTerminated;
			logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2CompletedIntegratorStep", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	if(comp->fmuType==fmi2ModelExchange && comp->S.wset)
		for(i=NDIFF+1;i<=NDIFF+NIX1-NINP;i++)
			comp->S.wset[i]=comp->S.w[i];
	SolverOutputs(&(comp->S));
	if( comp->S.w[0]>=(comp->vidlasttime+comp->minSampleStep)*(1-1e-15) ) {
		comp->vidsts=2;
		comp->vidlasttime=comp->S.w[0];
	}
 	if (comp->fptr)
		if ( comp->S.w[0]>=(comp->lastsampletime+comp->minSampleStep)*(1-1e-15) ) {
			fwrite(comp->S.w,sizeof(fmi2Real),NEQ+1,comp->fptr);
			comp->lastsampletime=comp->S.w[0];
			if ( comp->numpts++ == WARNNUMDATPTS )
				compLog(compEnv, comp->instanceName, fmi2Warning, "warning",
						"[fmi2CompletedIntegratorStep]: At time t=%.16g, %d data points were written into file %s; consider increasing the minimum sample step, %.16g, to limit file size.",
						comp->S.w[0], WARNNUMDATPTS, comp->fstr, comp->minSampleStep);
		}

#if !defined(WMI_PROJECTION) && NCON>0
#   if defined(CONDSTEPEVENT)
	for(i=0;i<NEQ;i++) save[i]=comp->S.w[i+1];
	i=SolverProject(&(comp->S));
	if (i<0 || errorOccured>=1) {
		errorOccured=0;
		*enterEventMode = fmi2True;
	}
	else if (i>0) {
		setVidError(comp,NULL);
		if (comp->fptr) {
			writeErrorToFile(comp->fptr,NULL);
			comp->fptr = NULL;
		}
		comp->state = modelTerminated;
		*terminateSimulation = fmi2True;
		logMessage(comp, "fmi2CompletedIntegratorStep", "error", fmi2Discard);
		return fmi2OK;
	}
	else {
		drift=0.0;
		for(i=0;i<NEQ;i++) {
			val=1e-15;
			if(fabs(save[i])>val) val=fabs(save[i]);
			if(fabs(comp->S.w[i+1])>val) val=fabs(comp->S.w[i+1]);
			val=fabs(comp->S.w[i+1]-save[i])/val;
			if(val>drift) drift=val;
		}
		val=(CONTOL<1e-8) ? 1e-10 : 0.01*CONTOL;
		if(drift>val)
			*enterEventMode = fmi2True;
		else
			*enterEventMode = fmi2False;
	}
	for(i=0;i<NEQ;i++) comp->S.w[i+1]=save[i];
#   else
	*enterEventMode = fmi2True;
#   endif
#else
	*enterEventMode = fmi2False;
#endif

	return fmi2OK;
}
/* END: fmi2CompletedIntegratorStep */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetTime */
fmi2Status fmi2SetTime(	fmi2Component	c,
						fmi2Real		time) {
	ModelInstance* comp = (ModelInstance *)c;
	if (invalidState(comp, "fmi2SetTime", modelInstantiated|modelInitialized))
		return fmi2Error;
	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2SetTime: time = %.16g", time);
	if (comp->S.w[0] != time) {
		comp->S.w[0] = time;
		comp->synced = fmi2False;
		comp->jsynced = fmi2False;
	}
	return fmi2OK;
}
/* END: fmi2SetTime */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2SetContinuousStates */
fmi2Status fmi2SetContinuousStates(	fmi2Component	c,
									const fmi2Real	x[],
									size_t			nx){
	ModelInstance* comp = (ModelInstance *)c;
#if NDIFF>0
	double scalev;
	int i;
	fmi2ValueReference vr;
#endif

	if (invalidState (comp, "fmi2SetContinuousStates", modelInitialized))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2SetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2SetContinuousStates", "x[]", x))
		return fmi2Error;

	for (i=0; i<(int)nx; i++) {
		vr = vrStates[i];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2SetContinuousStates: #r%d# = %.16g", vr, x[i]);
		/*assert(vr>=0 && vr<NUMBER_OF_REALS);*/
		if( nomfac )
			scalev = nomfac[i]*x[i];
		else
			scalev = x[i];
		if (comp->S.w[vr] != scalev) {
			comp->S.w[vr] = scalev;
			comp->synced = fmi2False;
			comp->jsynced = fmi2False;
		}
	}
#endif
	return fmi2OK;
}
/* END: fmi2SetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetDerivatives */
fmi2Status fmi2GetDerivatives(	fmi2Component	c,
								fmi2Real		derivatives[],
								size_t			nx) {
#if NDIFF>0
	int i;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetDerivatives", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetDerivatives", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetDerivatives", "derivatives[]", derivatives))
		return fmi2Error;

#if NDIFF>0
	if (comp->state==modelInitialized && !comp->synced) {
		SolverUpdate(&(comp->S),0,0);
		if(errorOccured>0) {
			setVidError(comp,NULL);
			if (comp->fptr) {
				writeErrorToFile(comp->fptr,NULL);
				comp->fptr = NULL;
			}
			errorOccured=0;
			logMessage(comp, "fmi2GetDerivatives", "error", fmi2Discard);
			return fmi2Discard;
		}
		else if(errorOccured<0) {
			logMessage(comp, "fmi2GetDerivatives", "warning", fmi2Warning);
			errorOccured=0;
		}
		comp->synced = fmi2True;
		comp->jsynced = fmi2False;
	}
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			derivatives[i] = comp->S.w[vrDers[i]]/nomfac[i];
		else
			derivatives[i] = comp->S.w[vrDers[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetDerivatives: #r%d# = %.16g",	vrDers[i], derivatives[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetDerivatives */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetEventIndicators */
fmi2Status fmi2GetEventIndicators(	fmi2Component	c,
									fmi2Real		eventIndicators[],
									size_t			ni) {
#if NEVT>0
	int i;
	M_INT *modes;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetEventIndicators", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetEventIndicators", "ni", ni, NEVT))
		return fmi2Error;

#if NEVT>0
	sts = syncModel(c,"fmi2GetEventIndicators");
	if ( sts!=fmi2OK ) return(sts);
	eev(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[1]),eventIndicators);
	modes=comp->S.iw;
	ComputeEventIndicators(eventIndicators,&(comp->S.w[1]),modes,
		&modes[3*NEVT],&modes[2*NEVT],&modes[4*NEVT]);
	for (i=0; i<(int)ni; i++) {
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetEventIndicators: z%d = %.16g",
					i, eventIndicators[i]);
	}
#else
	UNUSED(eventIndicators);
#endif
	return fmi2OK;
}
/* END: fmi2GetEventIndicators */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetContinuousStates */
fmi2Status fmi2GetContinuousStates(	fmi2Component	c,
									fmi2Real		states[],
									size_t			nx) {
#if NDIFF>0
	int i;
	fmi2Status sts;
#endif
	ModelInstance* comp = (ModelInstance *)c;

	if (invalidState (comp, "fmi2GetContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
#if NDIFF>0
	if (nullPointer  (comp, "fmi2GetContinuousStates", "states[]", states))
		return fmi2Error;

	sts = syncModel(c,"fmi2GetContinuousStates");
	if ( sts!=fmi2OK ) return(sts);
	for (i=0; i<(int)nx; i++) {
		if( nomfac )
			states[i] = comp->S.w[vrStates[i]]/nomfac[i];
		else
			states[i] = comp->S.w[vrStates[i]];
		if (comp->loggingOn)
			compLog(compEnv, comp->instanceName, fmi2OK, "log",
					"fmi2GetContinuousStates: #r%u# = %.16g", vrStates[i], states[i]);
	}
#endif
	return fmi2OK;
}
/* END: fmi2GetContinuousStates */
/*****************************************************************************/

/*****************************************************************************/
/* BEGIN: fmi2GetNominalsOfContinuousStates */
fmi2Status fmi2GetNominalsOfContinuousStates(fmi2Component	c,
											fmi2Real		x_nominal[],
											size_t			nx) {
	ModelInstance* comp = (ModelInstance *)c;
	int i;

	if (invalidState (comp, "fmi2GetNominalsOfContinuousStates", validGet))
		return fmi2Error;
	if (invalidNumber(comp, "fmi2GetNominalsOfContinuousStates", "nx", nx, NDIFF))
		return fmi2Error;
	if (nullPointer  (comp, "fmi2GetNominalsOfContinuousStates", "x_nominal[]", x_nominal))
		return fmi2Error;

	if (comp->loggingOn)
		compLog(compEnv, comp->instanceName, fmi2OK, "log",
				"fmi2GetNominalsOfContinuousStates: x_nominal[0..%d] = 1.0", nx-1);
	if( nomfac )
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0/nomfac[i-1];
	else
		for (i=0; i<(int)nx; i++) x_nominal[i] = 1.0;

	return fmi2OK;
}
/* END: fmi2GetNominalsOfContinuousStates */
/*****************************************************************************/

#endif

/*****************************************************************************/
/* Special purpose data communication functions */

typedef fmi2Status getMapleSimVideoDataLengthTYPE(fmi2Component, fmi2Integer *);
#define getMapleSimVideoDataLength fmi2FullName(getMapleSimVideoDataLength)
FMI2_Export getMapleSimVideoDataLengthTYPE getMapleSimVideoDataLength;

fmi2Status getMapleSimVideoDataLength(fmi2Component c, fmi2Integer *len)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0) {
		*len=0;
		return(fmi2Warning);
	}
	else if(comp->vidsts==1)
		*len=2+NPAR;
	else if(comp->vidsts==2)
		*len=NEQ+1;
	else if(comp->vidsts==-1)
		*len=2+strlen(comp->viderror)/8;
	else {
		*len=0;
		return(fmi2Error);
	}
	return(fmi2OK);
}

typedef fmi2Status getMapleSimVideoDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimVideoData fmi2FullName(getMapleSimVideoData)
FMI2_Export getMapleSimVideoDataTYPE getMapleSimVideoData;

fmi2Status getMapleSimVideoData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(comp->vidsts==0)
		return(fmi2Error);
	else if(comp->vidsts==1) {
		data[0]=nData[0];
		data[1]=nData[1];
		memcpy(&data[2],&comp->S.w[NEQ+1],NPAR*sizeof(fmi2Real));
	}
	else if(comp->vidsts==2)
		memcpy(data,comp->S.w,(NEQ+1)*sizeof(fmi2Real));
	else if(comp->vidsts==-1) {
		data[0]=-1e10;
		memcpy(&data[1],comp->viderror,strlen(comp->viderror)+1);
	}
	else
		return(fmi2Error);
	comp->vidsts=0;
	return(fmi2OK);
}

typedef fmi2Status getMapleSimAuxiliaryDataTYPE(fmi2Component, fmi2Real *);
#define getMapleSimAuxiliaryData fmi2FullName(getMapleSimAuxiliaryData)
FMI2_Export getMapleSimAuxiliaryDataTYPE getMapleSimAuxiliaryData;

fmi2Status getMapleSimAuxiliaryData(fmi2Component c, fmi2Real *data)
{
	ModelInstance* comp = (ModelInstance *)c;

	if(!comp->synced) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2Discard);
	}
	else if(comp->state==modelInitialized) {
		auxp(comp->S.w[0],&(comp->S.w[1]),&(comp->S.w[NEQ+NPAR+1]),data);
		return(fmi2OK);
	}
	else return(fmi2Error);
}
